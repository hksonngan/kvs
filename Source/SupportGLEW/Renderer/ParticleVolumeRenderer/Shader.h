/* DONT'T EDIT THIS FILE.
 * THIS IS GENERATED BY "Configure/configure_shader.py".
 */
#ifndef KVS__GLEW__GLSL__ParticleVolumeRenderer_H_INCLUDE
#define KVS__GLEW__GLSL__ParticleVolumeRenderer_H_INCLUDE

namespace kvs { namespace glew { namespace glsl {

namespace ParticleVolumeRenderer
{

namespace Vertex
{

const char* resize =
    "\n"
    "void main( void )\n"
    "{\n"
    "    gl_Position = ftransform();\n"
    "    gl_TexCoord[0] = gl_MultiTexCoord0;\n"
    "    gl_FrontColor = gl_Color;\n"
    "}\n"
;

const char* zooming =
    "uniform float densityFactor;\n"
    "uniform int circleThreshold;\n"
    "uniform vec2 screenScale;\n"
    "#if defined( ENABLE_RANDOM_TEXTURE )\n"
    "uniform sampler2D randomTexture;\n"
    "uniform float randomTextureSizeInv;\n"
    "attribute vec2 identifier;\n"
    "#endif\n"
    "\n"
    "const float circleScale = 0.564189583547756; // 1.0 / sqrt(PI)\n"
    "\n"
    "varying vec3 position;\n"
    "varying vec3 normal;\n"
    "\n"
    "varying vec2 centerCoord;\n"
    "varying float radius;\n"
    "\n"
    "\n"
    "#if defined( ENABLE_RANDOM_TEXTURE )\n"
    "float zooming( in vec4 p )\n"
    "{\n"
    "    // Get a random number.\n"
    "    vec2 randomPos = identifier * randomTextureSizeInv;\n"
    "    float random = texture2D( randomTexture, randomPos ).x;\n"
    "\n"
    "    float distance = p.z;\n"
    "    if ( distance < 1.0 ) distance = 1.0; // to avoid front-clip\n"
    "\n"
    "    float point_size = densityFactor / distance;\n"
    "    float point_size_floor = floor( point_size );\n"
    "    float point_size_ceil = ceil ( point_size );\n"
    "    float point_size_fraction = fract( point_size );\n"
    "    float probability_ceil = point_size_fraction * (2.0 * point_size_floor + point_size_fraction) / (2.0 * point_size_floor + 1.0);\n"
    "    if ( circleThreshold <= 0 || point_size <= float( circleThreshold ) )\n"
    "    {\n"
    "        // Draw a particle as square.\n"
    "        point_size = ((random < probability_ceil) ? point_size_ceil : point_size_floor) ;\n"
    "        radius = 0.0;\n"
    "    }\n"
    "    else\n"
    "    {\n"
    "        // Draw a particle as circle.\n"
    "        // Convert position to screen coordinates.\n"
    "        centerCoord = screenScale + ( ( p.xy / p.w ) * screenScale );\n"
    "        radius = ( ( random < probability_ceil ) ? point_size_ceil : point_size_floor ) * circleScale;\n"
    "        point_size = ceil( point_size * circleScale * 2.0 ) + 1.0;\n"
    "    }\n"
    "\n"
    "    return( point_size );\n"
    "}\n"
    "\n"
    "#else\n"
    "float zooming( in vec4 p )\n"
    "{\n"
    "    float distance = p.z;\n"
    "    if ( distance < 1.0 ) distance = 1.0; // to avoid front-clip\n"
    "\n"
    "    // Calculate particle size.\n"
    "    float point_size = densityFactor / distance;\n"
    "    float point_size_floor = floor( point_size );\n"
    "    float point_size_ceil = ceil( point_size );\n"
    "\n"
    "    // Generate a random floating point using the vertex position.\n"
    "    float myF = p.x + p.z * p.y;\n"
    "    int randi = int( myF * float( 0x0000ffff ) ); // pick 4 bits using mask\n"
    "    randi = randi & 0x000000f0;\n"
    "    randi >>= 4;\n"
    "    float randf = float( randi ) / 16.0;\n"
    "    float rand_size = randf + point_size_floor;\n"
    "\n"
    "    // Select the floor value or the ceiling value randomly as the particle size.\n"
    "    if ( circleThreshold <= 0 || point_size <= float( circleThreshold ) )\n"
    "    {\n"
    "        // Draw a particle as square.\n"
    "        point_size = ( point_size < rand_size ) ? point_size_floor : point_size_ceil;\n"
    "        radius = 0.0;\n"
    "    }\n"
    "    else\n"
    "    {\n"
    "        // Draw a particle as circle.\n"
    "        // Convert position to screen coordinates.\n"
    "        centerCoord = screenScale + ( ( p.xy / p.w ) * screenScale );\n"
    "        radius = ( ( point_size < rand_size ) ? point_size_floor : point_size_ceil ) * circleScale;\n"
    "        point_size = ceil( point_size * circleScale * 2.0 ) + 1.0;\n"
    "    }\n"
    "\n"
    "    return( point_size );\n"
    "}\n"
    "#endif\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    gl_FrontColor = gl_Color;\n"
    "    gl_Position = ftransform();\n"
    "\n"
    "    normal = gl_Normal.xyz;\n"
    "    position = vec3( gl_ModelViewMatrix * gl_Vertex );\n"
    "\n"
    "    gl_PointSize = zooming( gl_Position );\n"
    "}\n"
;

} // end of namespace Vertex

namespace Fragment
{

const char* resize =
    "uniform sampler2D texture;\n"
    "uniform vec2 start;\n"
    "uniform vec2 step;\n"
    "uniform ivec2 count;\n"
    "uniform float scale;\n"
    "\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "#if 0 // don't use linear interpolation\n"
    "    int x, y;\n"
    "    vec2 pos1, pos2;\n"
    "    vec4 c = vec4( 0.0, 0.0, 0.0, 0.0 );\n"
    "    pos1 = gl_TexCoord[0].st + start;\n"
    "    for ( y = 0; y < count.t; y++ )\n"
    "    {\n"
    "        pos2 = pos1;\n"
    "        for ( x = 0; x < count.s; x++ )\n"
    "        {\n"
    "            c += texture2D( texture, pos2 );\n"
    "            pos2.s += step.s;\n"
    "        }\n"
    "        pos1.t += step.t;\n"
    "    }\n"
    "    gl_FragColor = c * scale;\n"
    "#else\n"
    "    int x, y;\n"
    "    vec2 pos1, pos2, pos3;\n"
    "    vec4 c = vec4( 0.0, 0.0, 0.0, 0.0 );\n"
    "    pos1 = gl_TexCoord[0].st + start;\n"
    "    float weightxy, weighty;\n"
    "    for ( y = 0; y < count.t; y++ )\n"
    "    {\n"
    "        pos2 = pos1;\n"
    "        if ( x+1 < count.s )\n"
    "        {\n"
    "            // vertical interpolation\n"
    "            weighty = 2.0;\n"
    "            pos2.t += step.t * 0.5;\n"
    "            y++;\n"
    "            pos1.t += step.t;\n"
    "        }\n"
    "        else\n"
    "        {\n"
    "            weighty = 1.0;\n"
    "        }\n"
    "        for ( x = 0; x < count.s; x++ )\n"
    "        {\n"
    "            weightxy = weighty;\n"
    "            pos3 = pos2;\n"
    "            if ( x+1 < count.s )\n"
    "            {\n"
    "                // horizontal interpolation\n"
    "                weightxy = weighty * 2.0;\n"
    "                pos3.s += step.s * 0.5;\n"
    "                x++;\n"
    "                pos2.s += step.s;\n"
    "            }\n"
    "            c += texture2D( texture, pos3 ) * weightxy;\n"
    "            pos2.s += step.s;\n"
    "        }\n"
    "        pos1.t += step.t;\n"
    "    }\n"
    "    gl_FragColor = c * scale;\n"
    "    gl_FragColor.a = gl_Color.a;\n"
    "#endif\n"
    "}\n"
;

const char* zooming =
    "struct Shading\n"
    "{\n"
    "    float Ka; // ambient\n"
    "    float Kd; // diffuse\n"
    "    float Ks; // specular\n"
    "    float S;  // shininess\n"
    "};\n"
    "\n"
    "vec3 ShadingNone( in Shading shading, in vec3 color )\n"
    "{\n"
    "    return( color );\n"
    "}\n"
    "\n"
    "vec3 ShadingLambert( in Shading shading, in vec3 color, in vec3 L, in vec3 N )\n"
    "{\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "\n"
    "    float Ia = shading.Ka;\n"
    "    float Id = shading.Kd * dd;\n"
    "\n"
    "    return( color * ( Ia + Id ) );\n"
    "}\n"
    "\n"
    "vec3 ShadingPhong( in Shading shading, in vec3 color, in vec3 L, in vec3 N, in vec3 V )\n"
    "{\n"
    "    vec3 R = reflect( -L, N );\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "    float ds = pow( max( dot( R, V ), 0.0 ), shading.S );\n"
    "    if ( dd <= 0.0 ) ds = 0.0;\n"
    "\n"
    "    float Ia = shading.Ka;\n"
    "    float Id = shading.Kd * dd;\n"
    "    float Is = shading.Ks * ds;\n"
    "\n"
    "    return( color * ( Ia + Id ) + Is );\n"
    "}\n"
    "\n"
    "vec3 ShadingBlinnPhong( in Shading shading, in vec3 color, in vec3 L, in vec3 N, in vec3 V )\n"
    "{\n"
    "    vec3 H = normalize( L + V );\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "    float ds = pow( max( dot( H, N ), 0.0 ), shading.S );\n"
    "    if ( dd <= 0.0 ) ds = 0.0;\n"
    "\n"
    "    float Ia = shading.Ka;\n"
    "    float Id = shading.Kd * dd;\n"
    "    float Is = shading.Ks * ds;\n"
    "\n"
    "    return( color * ( Ia + Id ) + Is );\n"
    "}\n"
    "\n"
    "varying vec3 position;\n"
    "varying vec3 normal;\n"
    "\n"
    "varying vec2 centerCoord;\n"
    "varying float radius;\n"
    "\n"
    "uniform Shading shading;\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    // Discard a pixel outside circle.\n"
    "    if ( radius > 0.0 )\n"
    "    {\n"
    "        if( distance( gl_FragCoord.xy, centerCoord ) > radius ) discard;\n"
    "    }\n"
    "\n"
    "    // Light position.\n"
    "    vec3 light_position = gl_LightSource[0].position.xyz;\n"
    "\n"
    "    // Light vector (L) and Normal vector (N)\n"
    "    vec3 L = normalize( light_position - position );\n"
    "    vec3 N = normalize( gl_NormalMatrix * normal );\n"
    "\n"
    "#if   defined( ENABLE_LAMBERT_SHADING )\n"
    "    vec3 shaded_color = ShadingLambert( shading, gl_Color.xyz, L, N );\n"
    "\n"
    "#elif defined( ENABLE_PHONG_SHADING )\n"
    "    vec3 V = normalize( -position );\n"
    "    vec3 shaded_color = ShadingPhong( shading, gl_Color.xyz, L, N, V );\n"
    "\n"
    "#elif defined( ENABLE_BLINN_PHONG_SHADING )\n"
    "    vec3 V = normalize( -position );\n"
    "    vec3 shaded_color = ShadingBlinnPhong( shading, gl_Color.xyz, L, N, V );\n"
    "\n"
    "#else // DISABLE SHADING\n"
    "    vec3 shaded_color = ShadingNone( shading, gl_Color.xyz );\n"
    "#endif\n"
    "\n"
    "    gl_FragColor.xyz = shaded_color;\n"
    "    gl_FragColor.w = 1.0;\n"
    "}\n"
;

} // end of namespace Fragment

} // end of namespace ParticleVolumeRenderer

} } } // end of namespace kvs, glew, glsl

#endif // KVS__GLEW__GLSL__ParticleVolumeRenderer_H_INCLUDE
