/* DON'T EDIT THIS FILE.
 * THIS IS GENERATED BY "shader2header.c".
 */
#ifndef KVS__GLEW__GLSL__ParticleVolumeRenderer_H_INCLUDE
#define KVS__GLEW__GLSL__ParticleVolumeRenderer_H_INCLUDE

namespace kvs
{

namespace glew
{

namespace glsl
{

namespace ParticleVolumeRenderer
{

namespace Vertex
{

const char* zooming_with_random_texture =
    "uniform float densityFactor;\n"
    "uniform sampler2D randomTexture;\n"
    "uniform float randomTextureSizeInv;\n"
    "uniform int circleThreshold;\n"
    "uniform vec2 screenScale;\n"
    "\n"
    "const float circleScale = 0.564189583547756; // 1.0 / sqrt(PI)\n"
    "\n"
    "attribute vec2 identifier;\n"
    "\n"
    "varying vec3 position;\n"
    "varying vec3 normal;\n"
    "\n"
    "varying vec2 centerCoord;\n"
    "varying float radius;\n"
    "\n"
    "\n"
    "void main(void)\n"
    "{\n"
    "    gl_FrontColor = gl_Color;\n"
    "    gl_Position = ftransform();\n"
    "    normal = gl_Normal.xyz;\n"
    "    position = gl_Position.xyz;\n"
    "\n"
    "    // Get a random number.\n"
    "    vec2 randomPos = identifier * randomTextureSizeInv;\n"
    "    float random = texture2D( randomTexture, randomPos ).x;\n"
    "\n"
    "    float distance = gl_Position.z;\n"
    "    if ( distance < 1.0 ) distance = 1.0; // to avoid front-clip\n"
    "    float point_size = densityFactor / distance;\n"
    "    float point_size_floor = floor( point_size );\n"
    "    float point_size_ceil = ceil ( point_size );\n"
    "    float point_size_fraction = fract( point_size );\n"
    "    float probability_ceil = point_size_fraction * (2.0 * point_size_floor + point_size_fraction) / (2.0 * point_size_floor + 1.0);\n"
    "    if ( circleThreshold <= 0 || point_size <= float( circleThreshold ) )\n"
    "    {\n"
    "        // Draw a particle as square.\n"
    "        gl_PointSize = ((random < probability_ceil) ? point_size_ceil : point_size_floor) ;\n"
    "        radius = 0.0;\n"
    "    }\n"
    "    else\n"
    "    {\n"
    "        // Draw a particle as circle.\n"
    "        // Convert position to screen coordinates.\n"
    "        centerCoord = screenScale + ( ( gl_Position.xy / gl_Position.w ) * screenScale );\n"
    "        radius = ( ( random < probability_ceil ) ? point_size_ceil : point_size_floor ) * circleScale;\n"
    "        gl_PointSize = ceil( point_size * circleScale * 2.0 ) + 1.0;\n"
    "    }\n"
    "}\n"
;

const char* zooming =
    "uniform float densityFactor;\n"
    "uniform int circleThreshold;\n"
    "uniform vec2 screenScale;\n"
    "\n"
    "const float circleScale = 0.564189583547756; // 1.0 / sqrt(PI)\n"
    "\n"
    "varying vec3 position;\n"
    "varying vec3 normal;\n"
    "\n"
    "varying vec2 centerCoord;\n"
    "varying float radius;\n"
    "\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    gl_FrontColor = gl_Color;\n"
    "    gl_Position = ftransform();\n"
    "\n"
    "    normal = gl_Normal.xyz;\n"
    "    position = gl_Position.xyz;\n"
    "\n"
    "    float distance = gl_Position.z;\n"
    "    if ( distance < 1.0 ) distance = 1.0; // to avoid front-clip\n"
    "\n"
    "    // Calculate particle size.\n"
    "    float point_size = densityFactor / distance;\n"
    "    float point_size_floor = floor( point_size );\n"
    "    float point_size_ceil = ceil( point_size );\n"
    "\n"
    "    // Generate a random floating point using the vertex position.\n"
    "    float myF = gl_Position.x + gl_Position.z * gl_Position.y;\n"
    "    int randi = int( myF * float( 0x0000ffff ) ); // pick 4 bits using mask\n"
    "    randi = randi & 0x000000f0;\n"
    "    randi >>= 4;\n"
    "    float randf = float( randi ) / 16.0;\n"
    "    float rand_size = randf + point_size_floor;\n"
    "\n"
    "    // Select the floor value or the ceiling value randomly as the particle size.\n"
    "    if ( circleThreshold <= 0 || point_size <= float( circleThreshold ) )\n"
    "    {\n"
    "        // Draw a particle as square.\n"
    "        gl_PointSize = ( point_size < rand_size ) ? point_size_floor : point_size_ceil;\n"
    "        radius = 0.0;\n"
    "    }\n"
    "    else\n"
    "    {\n"
    "        // Draw a particle as circle.\n"
    "        // Convert position to screen coordinates.\n"
    "        centerCoord = screenScale + ( ( gl_Position.xy / gl_Position.w ) * screenScale );\n"
    "        radius = ( ( point_size < rand_size ) ? point_size_floor : point_size_ceil ) * circleScale;\n"
    "        gl_PointSize = ceil( point_size * circleScale * 2.0 ) + 1.0;\n"
    "    }\n"
    "}\n"
;

const char* resize =
    "\n"
    "void main( void )\n"
    "{\n"
    "    gl_Position = ftransform();\n"
    "    gl_TexCoord[0] = gl_MultiTexCoord0;\n"
    "    gl_FrontColor = gl_Color;\n"
    "}\n"
;

const char* nozooming =
    "varying vec3 position;\n"
    "varying vec3 normal;\n"
    "\n"
    "void main(void)\n"
    "{\n"
    "    gl_FrontColor = gl_Color;\n"
    "    gl_Position = ftransform();\n"
    "\n"
    "    normal = gl_Normal.xyz;\n"
    "    position = gl_Position.xyz;\n"
    "}\n"
;

} // end of namespace Vertex

namespace Fragment
{

const char* resize =
    "uniform sampler2D texture;\n"
    "uniform vec2 start;\n"
    "uniform vec2 step;\n"
    "uniform ivec2 count;\n"
    "uniform float scale;\n"
    "\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "#if 0 // don't use linear interpolation\n"
    "    int x, y;\n"
    "    vec2 pos1, pos2;\n"
    "    vec4 c = vec4( 0.0, 0.0, 0.0, 0.0 );\n"
    "    pos1 = gl_TexCoord[0].st + start;\n"
    "    for ( y = 0; y < count.t; y++ )\n"
    "    {\n"
    "        pos2 = pos1;\n"
    "        for ( x = 0; x < count.s; x++ )\n"
    "        {\n"
    "            c += texture2D( texture, pos2 );\n"
    "            pos2.s += step.s;\n"
    "        }\n"
    "        pos1.t += step.t;\n"
    "    }\n"
    "    gl_FragColor = c * scale;\n"
    "#else\n"
    "    int x, y;\n"
    "    vec2 pos1, pos2, pos3;\n"
    "    vec4 c = vec4( 0.0, 0.0, 0.0, 0.0 );\n"
    "    pos1 = gl_TexCoord[0].st + start;\n"
    "    float weightxy, weighty;\n"
    "    for ( y = 0; y < count.t; y++ )\n"
    "    {\n"
    "        pos2 = pos1;\n"
    "        if ( x+1 < count.s )\n"
    "        {\n"
    "            // vertical interpolation\n"
    "            weighty = 2.0;\n"
    "            pos2.t += step.t * 0.5;\n"
    "            y++;\n"
    "            pos1.t += step.t;\n"
    "        }\n"
    "        else\n"
    "        {\n"
    "            weighty = 1.0;\n"
    "        }\n"
    "        for ( x = 0; x < count.s; x++ )\n"
    "        {\n"
    "            weightxy = weighty;\n"
    "            pos3 = pos2;\n"
    "            if ( x+1 < count.s )\n"
    "            {\n"
    "                // horizontal interpolation\n"
    "                weightxy = weighty * 2.0;\n"
    "                pos3.s += step.s * 0.5;\n"
    "                x++;\n"
    "                pos2.s += step.s;\n"
    "            }\n"
    "            c += texture2D( texture, pos3 ) * weightxy;\n"
    "            pos2.s += step.s;\n"
    "        }\n"
    "        pos1.t += step.t;\n"
    "    }\n"
    "    gl_FragColor = c * scale;\n"
    "    gl_FragColor.a = gl_Color.a;\n"
    "#endif\n"
    "}\n"
;

const char* phong_shading =
    "uniform sampler2D randomTexture;\n"
    "uniform float randomTextureSizeInv;\n"
    "uniform float Ka;\n"
    "uniform float Kd;\n"
    "uniform float Ks;\n"
    "uniform float S;\n"
    "\n"
    "varying vec3 position;\n"
    "varying vec3 normal;\n"
    "\n"
    "varying vec2 centerCoord;\n"
    "varying float radius;\n"
    "\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    // Discard a pixel outside circle.\n"
    "    if ( radius > 0.0 )\n"
    "    {\n"
    "        if( distance( gl_FragCoord.xy, centerCoord ) > radius ) discard;\n"
    "    }\n"
    "\n"
    "    // Light vector (L), Normal vector (N) and Reflection vector (R).\n"
    "    vec3 L = normalize( gl_LightSource[0].position.xyz - position );\n"
    "    vec3 N = normalize( gl_NormalMatrix * normal );\n"
    "    vec3 R = 2.0 * dot( N, L ) * N - L;\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "    float ds = pow( max( dot( N, R ), 0.0 ), S );\n"
    "//    float ds = pow( max( dot( N, R ), 0.0 ), gl_FrontMaterial.shininess );\n"
    "\n"
    "    // I = Ia + Id + Is\n"
    "    vec3 Ia = vec3( Ka, Ka, Ka );\n"
    "    vec3 Id = vec3( Kd, Kd, Kd ) * dd;\n"
    "    vec3 Is = vec3( Ks, Ks, Ks ) * ds;\n"
    "//    vec3 Ia = vec3( Ka, Ka, Ka ) * gl_LightSource[0].ambient.rgb;\n"
    "//    vec3 Id = vec3( Kd, Kd, Kd ) * gl_LightSource[0].diffuse.rgb * dd;\n"
    "//    vec3 Is = vec3( Ks, Ks, Ks ) * gl_LightSource[0].specular.rgb * ds;\n"
    "\n"
    "    gl_FragColor.xyz = gl_Color.xyz * ( Ia + Id + Is );\n"
    "    gl_FragColor.w = 1.0;\n"
    "}\n"
;

const char* noshading =
    "varying vec2 centerCoord;\n"
    "varying float radius;\n"
    "\n"
    "\n"
    "void main(void)\n"
    "{\n"
    "    // Discard a pixel outside circle.\n"
    "    if ( radius > 0.0 )\n"
    "    {\n"
    "        if( distance( gl_FragCoord.xy, centerCoord ) > radius ) discard;\n"
    "    }\n"
    "\n"
    "    gl_FragColor = gl_Color;\n"
    "}\n"
;

const char* lambert_shading =
    "uniform sampler2D randomTexture;\n"
    "uniform float randomTextureSizeInv;\n"
    "uniform float Ka;\n"
    "uniform float Kd;\n"
    "\n"
    "varying vec3 position;\n"
    "varying vec3 normal;\n"
    "\n"
    "varying vec2 centerCoord;\n"
    "varying float radius;\n"
    "\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    // Discard a pixel outside circle.\n"
    "    if ( radius > 0.0 )\n"
    "    {\n"
    "        if( distance( gl_FragCoord.xy, centerCoord ) > radius ) discard;\n"
    "    }\n"
    "\n"
    "    // Light vector (L) and Normal vector (N)\n"
    "    vec3 L = normalize( gl_LightSource[0].position.xyz - position );\n"
    "    vec3 N = normalize( gl_NormalMatrix * normal );\n"
    "    float dd = max( dot( N, L ), 0.0 );\n"
    "\n"
    "    // I = Ia + Id\n"
    "//    vec3 Ia = vec3( Ka, Ka, Ka ) * gl_LightSource[0].ambient.rgb;\n"
    "//    vec3 Id = vec3( Kd, Kd, Kd ) * gl_LightSource[0].diffuse.rgb * dd;\n"
    "//    vec3 Ia = vec3( Ka, Ka, Ka );\n"
    "//    vec3 Id = vec3( Kd, Kd, Kd ) * dd;\n"
    "    float Ia = Ka;\n"
    "    float Id = Kd * dd;\n"
    "\n"
    "    gl_FragColor.xyz = gl_Color.xyz * ( Ia + Id );\n"
    "    gl_FragColor.w = 1.0;\n"
    "}\n"
;

const char* blinn_phong_shading =
    "uniform sampler2D randomTexture;\n"
    "uniform float randomTextureSizeInv;\n"
    "uniform float Ka;\n"
    "uniform float Kd;\n"
    "uniform float Ks;\n"
    "uniform float S;\n"
    "\n"
    "varying vec3 position;\n"
    "varying vec3 normal;\n"
    "\n"
    "varying vec2 centerCoord;\n"
    "varying float radius;\n"
    "\n"
    "\n"
    "void main( void )\n"
    "{\n"
    "    // Discard a pixel outside circle.\n"
    "    if ( radius > 0.0 )\n"
    "    {\n"
    "        if( distance( gl_FragCoord.xy, centerCoord ) > radius ) discard;\n"
    "    }\n"
    "\n"
    "    // Light vector (L), Normal vector (N) and Halfway vector (H).\n"
    "    vec3 C = normalize( position );\n"
    "    vec3 L = normalize( gl_LightSource[0].position.xyz - position );\n"
    "    vec3 N = normalize( gl_NormalMatrix * normal );\n"
    "    vec3 H = normalize( L + C );\n"
    "    float dd = max( dot( L, N ), 0.0 );\n"
    "    float ds = pow( max( dot( H, N ), 0.0 ), S );\n"
    "\n"
    "    // I = Ia + Id + Is\n"
    "    float Ia = Ka;\n"
    "    float Id = Kd * dd;\n"
    "    float Is = Ks * ds;\n"
    "\n"
    "    gl_FragColor.xyz = gl_Color.xyz * ( Ia + Id + Is );\n"
    "    gl_FragColor.w = 1.0;\n"
    "}\n"
;

} // end of namespace Fragment

} // end of namespace ParticleVolumeRenderer

} // end of namespace glsl

} // end of namesapce glew

} // end of namespace kvs

#endif // KVS__GLEW__GLSL__ParticleVolumeRenderer_H_INCLUDE
